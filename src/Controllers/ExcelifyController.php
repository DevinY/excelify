<?php

namespace Deviny\Excelify\Controllers;

use Illuminate\Http\Request;
use Illuminate\Routing\Controller;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;
use PhpOffice\PhpSpreadsheet\Cell\DataType;
use PhpOffice\PhpSpreadsheet\Cell\Coordinate; // 引入 Coordinate 類別用於 A1 座標轉換
use PhpOffice\PhpSpreadsheet\Writer\IWriter; // 雖然未使用，但保留以防未來需要
use Validator;
use GuzzleHttp\Client;
use Illuminate\Support\Str;
//use Log; // 註解掉的 Log 保持註解狀態

class ExcelifyController extends Controller
{
    protected $objPHPExcel; // PhpSpreadsheet 物件實例
    protected $tablename;   // 預設工作表名稱
    protected $tablenum;    // 要處理的 HTML 表格索引 (0 代表所有表格，1 代表第一個表格，依此類推)
    protected $rowData;     // 儲存從 HTML 表格解析出的資料
    protected $download_name; // 下載檔案的名稱
    protected $dom;         // 儲存從 URL 獲取的 HTML 中的所有 <table> 元素 (DOMNodeList)
    protected $rendertron_url; // Rendertron 服務的 URL，用於渲染 JavaScript 動態內容的網頁

    /**
     * 建構函式，初始化 PhpSpreadsheet 物件和預設下載名稱。
     */
    public function __construct()
    {
        $this->objPHPExcel = new Spreadsheet();
        $this->download_name = "download.xlsx";
    }

    /**
     * 顯示首頁視圖。
     *
     * @return \Illuminate\View\View
     */
    public function index()
    {
        return view('excelify::index')
            ->with('tabnum', 2); // 傳遞預設的 tab 數量
    }

    /**
     * 處理主要邏輯，從 URL 獲取 HTML 並將其表格轉換為 Excel。
     *
     * @param Request $r HTTP 請求物件
     * @return \Illuminate\View\View
     */
    public function __invoke(Request $r)
    {
        // 驗證輸入資料
        $validator = Validator::make($r->all(), [
            'url' => 'required|url', // 確保 URL 欄位存在且是有效的 URL
        ], [
            'url.required' => 'url|' . __('message.url required'), // 自訂錯誤訊息
            'url.url' => __('message.invalid url format'), // 新增：URL 格式錯誤訊息
        ])->validate();

        // 記住輸入資料，以便在重新載入頁面時保留
        $r->flash();
        session(['tabnum' => '2']); // 設定 session 中的 tab 數量

        $this->tablename = empty($r->tablename) ? "table" : $r->tablename;
        $this->tablenum = empty($r->tablenum) ? "0" : $r->tablenum; // 預設處理所有表格
        $this->rendertron_url = ($r->rendertron_url != '') ? $r->rendertron_url : '';

        // 設定 Excel 文件的屬性
        $objProps = $this->objPHPExcel->getProperties();
        $objProps->setCreator('excelify');
        $objProps->setTitle('Generated by Excelify'); // 新增：設定標題

        // 從指定 URL 獲取資料 (HTML 內容)
        $this->getData($r->url);

        // 如果沒有獲取到任何表格，則返回錯誤訊息或空資料
        if (!$this->dom || $this->dom->length === 0) {
            return view('excelify::index')
                ->with('data', [])
                ->with('datatype', 'table')
                ->with('tablenum', $this->tablenum)
                ->with('tablename', $this->tablename)
                ->with('tabnum', 2)
                ->withErrors(['url' => __('message.no table found or failed to load URL')]); // 新增錯誤提示
        }

        // 將 HTML 表格轉換為 Excel 工作表
        $this->tableToExcel();

        // 如果沒有解析到任何行資料，初始化為空陣列
        if (!isset($this->rowData)) {
            $this->rowData = [];
        }

        // 返回視圖並傳遞資料
        return view('excelify::index')
            ->with('data', $this->rowData)
            ->with('datatype', 'table')
            ->with('tablenum', $r->tablenum)
            ->with('tablename', $this->tablename)
            ->with('tabnum', 2);
    }

    /**
     * 從 URL 獲取 HTML 內容並解析其中的表格。
     *
     * @param string $data URL 或 HTML 字串
     * @return void
     */
    public function getData($data)
    {
        // 檢查是否為 URL
        if (preg_match('#^https?://#us', $data)) {
            // 如果設定了 Rendertron URL，則透過 Rendertron 服務獲取內容
            if ($this->rendertron_url != "") {
                // 為了避免快取問題，對 URL 添加時間戳
                $arrData = explode('?', $data);
                $data = $this->rendertron_url . urlencode($arrData[0]); // 使用 urlencode 確保 URL 編碼正確
                if (count($arrData) > 1) {
                    $data .= '%3F' . urlencode($arrData[1]); // 編碼查詢字串
                }
                $data .= '&_t=' . time(); // 添加時間戳防止快取
            }

            // 使用 GuzzleHttp 客戶端發送 GET 請求
            try {
                $http = new Client();
                $response = $http->get($data, ['timeout' => 30]); // 設定超時時間
                $data = (string) $response->getBody();
            } catch (\Exception $e) {
                // 捕獲 HTTP 請求錯誤
                // Log::error("Failed to fetch URL: " . $e->getMessage()); // 如果啟用 Log，可以記錄錯誤
                $this->dom = null; // 設定為 null 表示獲取失敗
                return;
            }
        }

        // 使用 DOMDocument 解析 HTML 內容
        $dom = new \DOMDocument();
        libxml_use_internal_errors(true); // 忽略解析錯誤，避免警告訊息
        $dom->loadHTML($data);
        libxml_clear_errors(); // 清除錯誤堆疊

        // 獲取所有 <table> 元素
        $this->dom = $dom->getElementsByTagName('table');
    }

    /**
     * 處理 Excel 檔案下載請求。
     *
     * @param Request $r HTTP 請求物件
     * @param int $tablenum 要下載的表格索引 (預設為 0)
     * @return \Symfony\Component\HttpFoundation\BinaryFileResponse
     */
    public function excelify(Request $r, $tablenum = 0)
    {
        $this->tablenum = $tablenum;
        $this->getData($r->table); // 這裡的 $r->table 應該是 HTML 內容或 URL

        // 如果沒有獲取到任何表格，則返回 404 或其他錯誤
        if (!$this->dom || $this->dom->length === 0) {
            abort(404, __('message.no table found to export'));
        }

        $this->tableToExcel();
        $name = isset($r->tablename) ? $r->tablename : 'download.xlsx';
        $this->download_name = sprintf("%s.xlsx", $name); // 確保檔案副檔名為 .xlsx

        return $this->download_temp();
    }

    /**
     * 清除指定時間以前的暫存檔案。
     *
     * @param int $times 時間戳 (秒)，表示要保留多久的檔案
     * @return void
     */
    protected function clear_temp_folder($times = 0)
    {
        $folderName = sprintf("%s/app/excelfile/", storage_path());
        if (file_exists($folderName)) {
            foreach (new \DirectoryIterator($folderName) as $fileInfo) {
                if ($fileInfo->isDot()) {
                    continue;
                }
                // 檢查檔案是否為檔案且創建時間是否超過指定時間
                if ($fileInfo->isFile() && time() - $fileInfo->getCTime() >= $times) {
                    unlink($fileInfo->getRealPath()); // 刪除檔案
                }
            }
        }
    }

    /**
     * 將解析出的 HTML 表格資料轉換並儲存到 Excel 暫存檔案。
     *
     * @return void
     */
    private function tableToExcel()
    {
        // 根據 $this->tablenum 判斷是處理所有表格還是特定表格
        if ($this->tablenum == 0) {
            // 處理所有表格，每個表格一個工作表
            $arrTables = $this->dom;
            foreach ($arrTables as $sheet_index => $table) {
                $this->create_sheet($table, $sheet_index);
            }
        } else {
            // 處理指定索引的表格 (注意 DOMNodeList 是 0-based 索引，所以需要 -1)
            if (isset($this->dom[$this->tablenum - 1])) {
                $table = $this->dom[$this->tablenum - 1];
                $this->create_sheet($table, 0); // 只創建一個工作表
            } else {
                // 如果指定的表格索引不存在，可以選擇拋出錯誤或記錄日誌
                // Log::warning("Specified table index {$this->tablenum} not found.");
                return; // 提前返回，不繼續生成 Excel
            }
        }

        // 如果暫存目錄不存在，則創建
        $excelFilePath = storage_path() . '/app/excelfile';
        if (!file_exists($excelFilePath)) {
            mkdir($excelFilePath, 0755, true); // 0755 權限，遞迴創建
        }

        // 清除舊的暫存檔案 (保留 2 天內的檔案)
        $this->clear_temp_folder(2 * 24 * 60 * 60);

        // 生成一個隨機檔案名稱作為暫存檔案的路徑
        $path = sprintf("excelfile/%s.xlsx", Str::random(10));

        // 記錄暫存檔案的路徑到 session
        session(['path' => $path]);

        // 儲存 Excel 檔案
        $this->objPHPExcel->setActiveSheetIndex(0); // 設定第一個工作表為活動工作表
        $objWriter = new Xlsx($this->objPHPExcel);
        $objWriter->save(storage_path() . "/app/" . $path);

        // 釋放記憶體
        $this->objPHPExcel->disconnectWorksheets(); // 斷開工作表，釋放記憶體
        unset($this->objPHPExcel);
        unset($objWriter);
    }

    /**
     * 創建一個新的工作表並將 HTML 表格資料寫入其中。
     *
     * @param \DOMElement $table HTML 表格元素
     * @param int $sheet_index 工作表索引
     * @return void
     */
    protected function create_sheet($table, $sheet_index)
    {
        // 如果不是第一個工作表，則創建新工作表
        if ($sheet_index > 0) {
            $this->objPHPExcel->createSheet($sheet_index);
        }
        $this->objPHPExcel->setActiveSheetIndex($sheet_index);

        // 設定工作表標題
        $this->objPHPExcel->getActiveSheet()->setTitle($this->tablename . ($sheet_index + 1));

        $arrTr = $table->getElementsByTagName('tr');
        $activeSheet = $this->objPHPExcel->getActiveSheet();
        $this->rowData = []; // 重置行資料，用於預覽

        $row_counter = 1; // Excel 行號從 1 開始

        foreach ($arrTr as $i => $tr) {
            $column_counter = 0; // Excel 欄號從 0 開始 (A=0, B=1...)
            $current_row_data = []; // 儲存當前行的資料用於預覽

            // 處理 <th> 標籤 (表頭)
            $arrTh = $tr->getElementsByTagName('th');
            foreach ($arrTh as $th) {
                // 移除隱藏的 span/div/label 標籤內容，並去除所有 HTML 標籤
                $pureText = strip_tags(preg_replace('#<(span|div|label)+.*display:none.+</(span|div|label)+>#us', '', $th->nodeValue));

                // 將欄位索引 (0-based) 轉換為 Excel 的 A1 樣式座標 (1-based)
                $cellCoordinate = Coordinate::stringFromColumnIndex($column_counter + 1) . $row_counter;

                // 處理資料類型並寫入 Excel
                if (is_numeric($pureText)) {
                    $activeSheet->getCell($cellCoordinate)->setValueExplicit((float)$pureText, DataType::TYPE_NUMERIC);
                } else {
                    // 解碼 HTML 實體，並移除不間斷空格
                    $pureText = htmlspecialchars_decode($pureText);
                    $pureText = preg_replace('/&nbsp;/uim', '', $pureText);
                    $activeSheet->getCell($cellCoordinate)->setValueExplicit($pureText, DataType::TYPE_STRING);
                }
                $current_row_data[$column_counter] = $pureText; // 儲存預覽資料
                $column_counter++;
            }

            // 處理 <td> 標籤 (表格資料)
            $arrTd = $tr->getElementsByTagName('td');
            foreach ($arrTd as $td) {
                // 移除隱藏的 span/div/label 標籤內容，並去除所有 HTML 標籤
                $pureText = strip_tags(preg_replace('#<(span|div|label)+.*display:none.+</(span|div|label)+>#us', '', $td->nodeValue));

                // 將欄位索引 (0-based) 轉換為 Excel 的 A1 樣式座標 (1-based)
                $cellCoordinate = Coordinate::stringFromColumnIndex($column_counter + 1) . $row_counter;

                // 處理資料類型並寫入 Excel
                if (is_numeric($pureText)) {
                    $activeSheet->getCell($cellCoordinate)->setValueExplicit((float)$pureText, DataType::TYPE_NUMERIC);
                } else {
                    // 解碼 HTML 實體，並移除不間斷空格
                    $pureText = htmlspecialchars_decode($pureText);
                    $pureText = preg_replace('/&nbsp;/uim', '', $pureText);
                    $activeSheet->getCell($cellCoordinate)->setValueExplicit($pureText, DataType::TYPE_STRING);
                }
                $current_row_data[$column_counter] = $pureText; // 儲存預覽資料
                $column_counter++;
            }
            $this->rowData[] = $current_row_data; // 將當前行資料添加到總行資料中
            $row_counter++; // 移到下一行
        }
    }

    /**
     * 下載暫存的 Excel 檔案。
     *
     * @return \Symfony\Component\HttpFoundation\BinaryFileResponse
     */
    function download_temp()
    {
        $path = session()->get('path');
        if (!$path || !file_exists(storage_path() . "/app/" . $path)) {
            abort(404, __('message.file not found or expired')); // 檔案不存在或已過期
        }

        return response()
            ->download(storage_path() . "/app/" . $path, $this->download_name)
            ->deleteFileAfterSend(true); // 下載後刪除暫存檔案
    }
}
